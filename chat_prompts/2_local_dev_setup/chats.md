## Prompt 1

Given these requirements and schema / api information, can you create a detailed list of user stories and their corresponding tasks that you will need to perform to achieve the requirements. Make the tasks granular, one task is one operation.

Requirements:
### Feature 1: Local Development & Foundation Setup

**Goal:** Establish the monorepo structure, initialize the core frameworks, and ensure the entire stack runs seamlessly on a local machine via Docker Compose.

* **Requirements:**
* Initialize a Vite + React + TypeScript frontend with Tailwind CSS and shadcn/ui.
* Initialize a FastAPI + Python backend with environment variable management.
* Set up a local PostgreSQL database instance.
* Configure Docker Compose to network the frontend, backend, and database together locally with hot-reloading enabled for development.


* **Deliverables:**
| Component | Deliverable Description |
| :--- | :--- |
| **Repository** | A standard monorepo folder structure (`/frontend`, `/backend`, `/infrastructure`). |
| **Docker** | `Dockerfile.dev` for both frontend and backend; a root `docker-compose.yml` file. |
| **Config Files** | `vite.config.ts` (proxying API requests to backend), `requirements.txt` / `pyproject.toml`, and a local `.env.example`. |

---

APIs/ Schemas:

1. Database Schemas (PostgreSQL)

To support the features—while allowing flexibility for different types of investment strategies, such as separating domestic trading from international brokerage accounts or tracking employee equity (RSUs)—we need a normalized relational structure.

#### `users`

Stores authentication and basic profile data.
| Column | Type | Constraints / Notes |
| :--- | :--- | :--- |
| `id` | UUID | Primary Key, default `uuid4()` |
| `email` | VARCHAR(255) | Unique, Not Null, Indexed |
| `password_hash` | VARCHAR(255) | Not Null (Argon2 or bcrypt) |
| `created_at` | TIMESTAMP | Default `now()` |

#### `portfolios`

Allows users to group their tracked stocks logically (e.g., "Tech Dividend Reinvestment", "Domestic Holdings").
| Column | Type | Constraints / Notes |
| :--- | :--- | :--- |
| `id` | UUID | Primary Key |
| `user_id` | UUID | Foreign Key -> `users.id`, On Delete Cascade |
| `name` | VARCHAR(100) | Not Null |
| `account_type` | VARCHAR(50) | e.g., 'DOMESTIC', 'INTERNATIONAL', 'EMPLOYEE_EQUITY' |
| `created_at` | TIMESTAMP | Default `now()` |

#### `portfolio_items`

The specific tickers associated with a portfolio.
| Column | Type | Constraints / Notes |
| :--- | :--- | :--- |
| `id` | UUID | Primary Key |
| `portfolio_id` | UUID | Foreign Key -> `portfolios.id`, On Delete Cascade |
| `ticker` | VARCHAR(20) | Not Null (e.g., 'GOOGL', 'RELIANCE.NS') |
| `added_at` | TIMESTAMP | Default `now()` |

#### `analysis_history`

Caches the Gemini analysis so users can review past AI recommendations without triggering new API calls.
| Column | Type | Constraints / Notes |
| :--- | :--- | :--- |
| `id` | UUID | Primary Key |
| `user_id` | UUID | Foreign Key -> `users.id` |
| `ticker` | VARCHAR(20) | Not Null |
| `rating` | VARCHAR(20) | 'BUY', 'HOLD', 'SELL' |
| `confidence` | INTEGER | 0 to 100 |
| `thesis` | TEXT | The detailed markdown thesis generated by Gemini |
| `created_at` | TIMESTAMP | Default `now()` |

#### `chat_sessions` & `chat_messages`

Stores the conversational memory for the WebSocket sidebar.
| Table | Column | Type | Constraints / Notes |
| :--- | :--- | :--- | :--- |
| **`chat_sessions`** | `id` | UUID | Primary Key |
| | `user_id` | UUID | Foreign Key -> `users.id` |
| | `context_ticker`| VARCHAR(20) | Nullable (If chat is tied to a specific stock) |
| **`chat_messages`** | `id` | UUID | Primary Key |
| | `session_id` | UUID | Foreign Key -> `chat_sessions.id` |
| | `sender_type` | VARCHAR(10) | 'USER' or 'AI' |
| | `content` | TEXT | The message body |
| | `created_at` | TIMESTAMP | Default `now()` |

---

Here is the granular, operation-by-operation breakdown of user stories and tasks for Feature 1 (Local Development & Foundation Setup) and the initial database schema implementation.

These are written so they can be dropped directly into a project management tool like Jira, Trello, or Linear.

### User Story 1: Monorepo & Docker Orchestration

**"As a developer, I want a containerized monorepo environment so that I can spin up the entire application stack locally with a single command."**

* **Task 1.1:** Create the root project directory (e.g., `stock-analysis-app`).
* **Task 1.2:** Create three subdirectories at the root level: `/frontend`, `/backend`, and `/infrastructure`.
* **Task 1.3:** Create a `.env.example` file in the root directory containing placeholder variables for POSTGRES_USER, POSTGRES_PASSWORD, POSTGRES_DB, and GEMINI_API_KEY.
* **Task 1.4:** Create a local `.env` file (and add it to `.gitignore`) by copying `.env.example`.
* **Task 1.5:** Create a `docker-compose.yml` file in the root directory.
* **Task 1.6:** Define a custom Docker bridge network in `docker-compose.yml` to allow the containers to communicate.

### User Story 2: PostgreSQL Database Provisioning

**"As a developer, I want a local PostgreSQL database running in Docker so that the backend can persist user and portfolio data."**

* **Task 2.1:** Add a `db` service to `docker-compose.yml` using the official `postgres:15-alpine` image.
* **Task 2.2:** Map local port `5432` to container port `5432` in the `db` service.
* **Task 2.3:** Map a local Docker volume to `/var/lib/postgresql/data` in the `db` service to ensure data persists across container restarts.
* **Task 2.4:** Inject the `POSTGRES_*` environment variables from the `.env` file into the `db` service.

### User Story 3: FastAPI Backend Foundation & Schema Definition

**"As a developer, I want a containerized FastAPI backend with hot-reloading and my database schemas defined so that I can begin building API routes."**

* **Task 3.1:** Create a `requirements.txt` in the `/backend` directory containing `fastapi`, `uvicorn`, `sqlalchemy`, `alembic`, `psycopg2-binary`, `python-dotenv`, and `pydantic`.
* **Task 3.2:** Create a `main.py` file in `/backend` and initialize a basic FastAPI app instance.
* **Task 3.3:** Create a `/backend/models.py` file and initialize the SQLAlchemy declarative base.
* **Task 3.4:** Define the `User` SQLAlchemy model with `id`, `email`, `password_hash`, and `created_at` columns.
* **Task 3.5:** Define the `Portfolio` SQLAlchemy model with a foreign key to `users.id` and the `account_type` column to handle categories like 'DOMESTIC' or 'EMPLOYEE_EQUITY'.
* **Task 3.6:** Define the `PortfolioItem` SQLAlchemy model with a foreign key to `portfolios.id`.
* **Task 3.7:** Define the `AnalysisHistory` SQLAlchemy model to cache Gemini's structured ratings and markdown theses.
* **Task 3.8:** Define the `ChatSession` and `ChatMessage` SQLAlchemy models to handle WebSocket memory.
* **Task 3.9:** Initialize Alembic in the `/backend` directory by running `alembic init alembic`.
* **Task 3.10:** Update `alembic.ini` and `env.py` to construct the database URL from environment variables and target the SQLAlchemy Base metadata.
* **Task 3.11:** Generate the first Alembic migration script (`alembic revision --autogenerate -m "Initial schema"`).
* **Task 3.12:** Create a `Dockerfile.dev` in the `/backend` directory using a Python 3.11 slim image, setting up the working directory, and installing requirements.
* **Task 3.13:** Set the CMD in the backend `Dockerfile.dev` to run Uvicorn with the `--reload` flag.
* **Task 3.14:** Add the `backend` service to `docker-compose.yml`, mapping the local `/backend` folder to the container to enable hot-reloading, and set it to `depends_on` the `db` service.

### User Story 4: React Frontend Foundation

**"As a developer, I want a containerized React frontend with Vite, Tailwind, and shadcn/ui configured so that I can start building the UI components."**

* **Task 4.1:** Run the Vite CLI to scaffold a React + TypeScript project inside the `/frontend` directory.
* **Task 4.2:** Install Tailwind CSS, PostCSS, and Autoprefixer via npm in the `/frontend` directory.
* **Task 4.3:** Initialize the Tailwind configuration (`npx tailwindcss init -p`).
* **Task 4.4:** Update `tailwind.config.js` to scan all React component files for utility classes.
* **Task 4.5:** Initialize `shadcn/ui` in the `/frontend` directory using their CLI tool.
* **Task 4.6:** Modify `vite.config.ts` to add a server proxy that routes all requests starting with `/api` to `http://backend:8000`.
* **Task 4.7:** Create a `Dockerfile.dev` in the `/frontend` directory using a Node.js alpine image.
* **Task 4.8:** Set the CMD in the frontend `Dockerfile.dev` to `npm run dev -- --host 0.0.0.0`.
* **Task 4.9:** Add the `frontend` service to `docker-compose.yml`, mapping the local `/frontend` folder to the container to enable Vite's Hot Module Replacement (HMR).

---

With these tasks, you have a rigid, step-by-step checklist to get the base of the app completely functional.

Would you like me to write out the actual code for the `docker-compose.yml` file and the backend `Dockerfile.dev` so you can knock out User Story 1 right away?

